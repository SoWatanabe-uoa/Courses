[le01]
A.c : 挿入ソート

入力：入力の最初の行に、数列の長さを表す整数 N が与えられます。2 行目に、N 個の整数が空白区切りで与えられます。

出力：出力は N 行からなります。挿入ソートの各計算ステップでの途中結果を 1 行に出力してください。
B.c : 最大公約数

[le02]
A.c : バブルソート

入力：入力の最初の行に、数列の長さを表す整数 N が与えられます。２行目に、N 個の整数が空白区切りで与えられます。

出力：出力は 2 行からなります。１行目に整列された数列を 1 行に出力してください。数列の連続する要素は１つの空白で区切って出力してください。2 行目に交換回数を出力してください。

B.c : 選択ソート

Aと同様

[le03]
A.c : stack

入力：１つの数式が１行に与えられます。連続するシンボル（オペランドあるいは演算子）は１つの空白で区切られて与えられます。

出力：計算結果を１行に出力してください

B.c : queue

入力：最初の行に、プロセス数を表す整数 n とクオンタムを表す整数 q が１つの空白区切りで与えられます。続く n 行で、各プロセスの情報が順番に与えられます。文字列 namei と整数 timei は１つの空白で区切られています。

出力：プロセスが完了した順に、各プロセスの名前と終了時刻を空白で区切って１行に出力してください。

[le04]
A.c : リニアサーチ

入力：１行目に n、２行目に Sを表す n個の整数、３行目に q、４行目に Tを表す q個の整数が与えられます。

出力：Tに含まれる整数の中で Sに含まれるものの個数 Cを１行に出力してください。
 
B.c : バイナリサーチ　( left, mid, right使う)

Aと同様

[le05]
A.c : 総当たり

入力：１行目に n、２行目に Aを表す n個の整数、３行目に q、４行目に q個の整数 miが与えられます。

出力：Aの要素を足しあわせて miを作ることができれば yes と、できなければ no と出力してください。
B.c : マージソート

入力：１行目に n、２行目に Sを表す n個の整数が与えられます。
出力：１行目に整列済みの数列 Sを出力してください。数列の隣り合う要素は１つの空白で区切ってくさい。２行目に比較回数を出力してください。

[le06]
CountingSort.c

入力：入力の最初の行に、数列 Aの長さを表す整数 nが与えられます。２行目に、n個の整数が空白区切りで与えられます。

出力：整列された数列を1行に出力してください。数列の連続する要素は１つの空白で区切って出力してください。

Partition.c

入力：入力の最初の行に、数列 Aの長さを表す整数 nが与えられます。２行目に、n個の整数 Ai(i=1,2...,n) が空白区切りで与えられます。

出力：分割された数列を1行に出力してください。数列の連続する要素は１つの空白で区切って出力してください。また、partition の基準となる要素を [   ]で示してください。

[le07]
RootedTrees.c

入力：入力の最初の行に、節点の個数 nが与えられます。続く n行目に、各節点の情報が次の形式で１行に与えられます。
id k c1 c2 ... ck
idは節点の番号、kは次数を表します。c1c2...ckは 1 番目の子の節点番号、... k番目の子の節点番号を示します。

BinaryTrees.c

入力：入力の最初の行に、節点の個数 nが与えられます。続く n行目に、各節点の情報が以下の形式で１行に与えられます。
id left right
idは節点の番号、leftは左の子の番号、rightは右の子の番号を表します。子を持たない場合は left
(right)は -1 で与えられます。

[le08]
BinarySearchTree1.c : 挿入と出力(inorder,preorder)

入力：入力の最初の行に、命令の数 mが与えられます。続く m行目に、insert kまたは print の形式で命令が１行に与えられます。
8
insert 30
insert 88
insert 12
insert 1
insert 20
insert 17
insert 25
print

BinarySearchTree2.c : BinarySearchTree1 + サーチ

[le09]
CompleteBinaryTree.c : ヒープで使う二分ぎ

入力：入力の最初の行に、二分ヒープのサイズ Hが与えられます。続いて、ヒープの節点の値（キー）を表す H個の整数がそれらの節点の番号順に空白区切りで与えられます。

MaximumHeap.c

入力：入力の最初の行に、ヒープのサイズ Hが与えられます。続いて、ヒープの節点の値を表す H個の整数が節点の番号が 1 から Hに向かって順番に空白区切りで与えられます。

出力：max-ヒープの節点の値を節点の番号が 1 から Hに向かって順番に１行に出力してください。各値の直前に１つの空白文字を出力してください。

[le10]
Fibonacci.c

入力：１つの整数 nが与えられます。
出力：フィボナッチ数列の第 n項の値を出力してください。

MatrixChainMultiplication.c : 連鎖行列積

入力：入力の最初の行に、行列の数 nが与えられます。続く n行で行列 Mi(i=1...n)の次元が空白区切りの２つの整数 r、cで与えられます。rは行列の行の数、cは行列の列の数を表します。

出力：最小の回数を１行に出力してください。

[le11]
Graph.c : 二次元配列使った

入力：最初の行に Gの頂点数 nが与えられます。続く n行で各頂点 uの隣接リスト Adj[u]
 が以下の形式で与えられます：
 u k v1 v2 ... vk
uは頂点の番号、kは uの出次数、v1v2...vkは uに隣接する頂点の番号を示します。

出力：出力例に従い、Gの隣接行列を出力してください。aijの間に１つの空白を入れてください。

DFS.c : 深さ優先探索

入力：Graph.cと同じ

出力：各頂点について id、 d、 fを空白区切りで１行に出力してください。idは頂点の番号、dはその頂点の発見時刻、fはその頂点の完了時刻です。頂点の番号順で出力してください。

[le12]
MinimumSpanningTree.c

入力：最初の行に Gの頂点数 nが与えられます。続く n行で Gを表す n×nの隣接行列 Aが与えられます。Aの要素 aijは、頂点 iと頂点 jを結ぶ辺の重みを表します。ただし、辺がなければ-1 で示されます。

出力：Gの最小全域木の辺の重みの総和を１行に出力してください。

SingleSourceShotestPath.c

入力：最初の行に Gの頂点数 nが与えられます。続く n行で各頂点 uの隣接リストが以下の形式で与えられます：
u k v1 c1 v2 c2 ... vk ck
Gの各頂点には 0から n−1の番号がふられています。uは頂点の番号であり、kは uの出次数を示します。vi(i=1,2,...k)は uに隣接する頂点の番号であり、ciは uと viをつなぐ有向辺の重みを示します。

出力：各頂点の番号 vと距離 d[v]を１つの空白区切りで順番に出力してください。
